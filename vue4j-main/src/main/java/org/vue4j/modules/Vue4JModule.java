package org.vue4j.modules;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URISyntaxException;
import java.net.URL;
import java.nio.file.FileSystem;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;
import java.util.logging.Level;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import org.apache.commons.io.IOUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.vue4j.Vue4J;
import org.vue4j.services.Vue4JService;
import org.vue4j.utils.ID;

public abstract class Vue4JModule implements ID, Vue4JService {

    protected final static Logger LOGGER = LoggerFactory.getLogger(Vue4JModule.class);

    private final Map<String, Object> configs = new HashMap<>();
    private final Map<String, Class<?>> configsClass = new HashMap<>();

    private Vue4J vue4J;

    public Vue4JModule() {
    }

    @Override
    public String getID() {
        return this.getClass().getCanonicalName();
    }

    public Vue4J getVue4J() {
        return vue4J;
    }

    public void setVue4J(Vue4J vue4J) {
        this.vue4J = vue4J;
    }

    protected ModuleLifeCycleStatus status = ModuleLifeCycleStatus.VISIBLE;

    public boolean isConstructed() {
        return status.equals(ModuleLifeCycleStatus.VISIBLE);
    }

    public boolean isConfigured() {
        return status.equals(ModuleLifeCycleStatus.CONFIGURED);
    }

    public boolean isActivated() {
        return status.equals(ModuleLifeCycleStatus.ACTIVATED);
    }

    public boolean isStarted() {
        return status.equals(ModuleLifeCycleStatus.STARTED);
    }

    public final void initialize() {
        if (isConstructed()) {
            try {
                configure();
                status = ModuleLifeCycleStatus.CONFIGURED;
                LOGGER.debug("Module configured : " + getID());
            } catch (Exception ex) {
                status = ModuleLifeCycleStatus.CONFIGURATION_ERROR;
                LOGGER.error("Error while configuring module: " + getID(), ex);
            }
        }
    }

    public boolean isEnabled() {
        return true;
    }
        
    public final void enable() {
        if (isEnabled() && isConfigured()) {
            try {
                activate();
                status = ModuleLifeCycleStatus.ACTIVATED;
                LOGGER.debug("Module activated : " + getID());
            } catch (Exception ex) {
                status = ModuleLifeCycleStatus.ACTIVATION_ERROR;
                LOGGER.error("Error while activating module: " + getID(), ex);
            }
        }
    }

    public boolean autoStart() {
        return false;
    }

    public final void run() {
        if (isActivated()) {
            try {
                start();
                status = ModuleLifeCycleStatus.STARTED;
                LOGGER.debug("Module started : " + getID());
            } catch (Exception ex) {
                status = ModuleLifeCycleStatus.STARTING_ERROR;
                LOGGER.error("Error while starting module: " + getID(), ex);
            }
        }
    }

    public final void shutdown() {
        if (isStarted()) {
            try {
                stop();
                status = ModuleLifeCycleStatus.ACTIVATED;
                LOGGER.debug("Module stopped : " + getID());
            } catch (Exception ex) {
                status = ModuleLifeCycleStatus.STOPPING_ERROR;
                LOGGER.error("Error while stopping module: " + getID(), ex);
            }
        }
    }

    public void disable() {
        if (isActivated()) {
            try {
                deactivate();
                status = ModuleLifeCycleStatus.STARTED;
                LOGGER.debug("Module deactivated : " + getID());
            } catch (Exception ex) {
                status = ModuleLifeCycleStatus.STARTING_ERROR;
                LOGGER.error("Error while deactivating module: " + getID(), ex);
            }
        }
    }

    public void clean() {
        if (isConfigured()) {
            try {
                destroy();
                LOGGER.debug("Module destroyed : " + getID());
            } catch (Exception ex) {
                LOGGER.error("Ignored error while destroying module: " + getID(), ex);
            }
            status = ModuleLifeCycleStatus.VISIBLE;
        }
    }

    /**
     * <pre>
     * Main application mavenProperties file generated by maven plugins.
     * It contains all mavenProperties defined in pom.xml during build
     * </pre>
     */
    private final static String APP_PROPERTIES = "app.properties";

    /**
     * Properties wich will be filled with those generated during maven build.
     */
    private Properties mavenProperties = new Properties();

    /**
     * Read Maven build properties.
     *
     * @return Return maven properties as an instance of {@code java.util.Properties}
     */
    public Properties getMavenProperties() {
        if (mavenProperties.isEmpty()) {
            try {
                // Read build mavenProperties generated by maven plugin
                final InputStream stream = getClass().getClassLoader().getResourceAsStream(APP_PROPERTIES);
                if (stream != null) {
                    mavenProperties.load(stream);
                    stream.close();
                }
            } catch (IOException ex) {
                LOGGER.error("Can't load maven properties for module: " + getID(), ex);
            }
        }

        return mavenProperties;
    }

    /**
     * Return version.
     *
     * @return version
     */
    public String getVersion() {
        return getMavenProperties().getProperty("revision", "");
    }

    public void registerConfig(String configID, Class<?> configClass, Object config) {
        configs.put(configID, config);
        configsClass.put(configID, configClass);
    }

    public Map<String, Object> getConfigs() {
        return configs;
    }

    public <T> T getConfig(String configID, Class<T> configClass) {
        if (!configs.containsKey(configID)) {
            return null;
        }

        return (T) configs.get(configID);
    }

    public Class<?> getConfigClass(String configID) {
        return configsClass.get(configID);
    }

    /**
     * Return configuration file of given profile in module.
     *
     * @param profileId Profile idnetifier
     * @return Inputstream of the configuration file
     */
    public InputStream getConfigFile(String profileId) {
        String yamlPath = "config/" + profileId + "/vue4j.yml";

        try {
            return getFileInputStream(yamlPath);
        } catch (Exception ex) {
            LOGGER.warn(getID() + " - Can't load config file: " + yamlPath, ex);
        }

        return null;
    }

    /**
     * Return file inside module as a {@code java.io.InputStream}.
     *
     * @param fileName File to get
     * @return Input stream of the file
     * @throws IOException In case of file access issues
     * @throws URISyntaxException In case of bad file URI (should never append)
     */
    public InputStream getFileInputStream(String fileName) throws IOException, URISyntaxException {
        URL sourceLocation = getClass().getProtectionDomain().getCodeSource().getLocation();
        String sourceLocationString = sourceLocation.toString();
        LOGGER.debug(getID() + " - Load file: " + fileName + " from: " + sourceLocationString);

        if (sourceLocationString.endsWith(".jar")) {
            // In case if module is a JAR
            File jarFile = Paths.get(sourceLocation.toURI()).toFile();

            // Create pseudo-filesystem from JAR as a ZIP file
            ZipFile zipFile = new ZipFile(jarFile);
            FileSystem fs = FileSystems.newFileSystem(Paths.get(jarFile.getAbsolutePath()), getClass().getClassLoader());
            Path file = fs.getPath(fileName);

            InputStream stream = null;
            if (Files.isRegularFile(file)) {
                // If file exists in JAR get it as a byte array
                ZipEntry entry = zipFile.getEntry(fileName);
                byte[] byteArray = IOUtils.toByteArray(zipFile.getInputStream(entry));
                // Convert this byte arry in input stram
                stream = new ByteArrayInputStream(byteArray);
            }

            // Close zip and return stream
            zipFile.close();
            return stream;

        } else {
            // In case if module is a folder (DEV MODE) directly return input stream
            File file = Paths.get(sourceLocation.toURI().resolve(fileName)).toFile();
            if (file.exists() && file.isFile()) {
                return new FileInputStream(file);
            }
        }

        return null;
    }
}
